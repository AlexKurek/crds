"""This module codifies standard practices for scripted interactions with the 
web server file submission system.
"""

import queue
import threading
import requests
from lxml import html

from crds import config, log, utils, exceptions
from crds.python23 import *

# ==================================================================================================

def log_section(section_name, section_value, verbosity=50, log_function=log.verbose, 
                divider_name=None):
    """Issue log divider bar followed by a corresponding log message."""
    log.divider(name=divider_name, verbosity=verbosity)
    log_function(section_name, section_value, verbosity=verbosity)

def background(f):
    """a threading decorator use @background above the function you want to run in the background.
    The decorated function returns (thread, queue) where queue will contain the function result
    and thead is already started but not joined.
    """

    def run_thread(*args, **keys):
        q = queue.Queue()
        def queue_put_f():
            q.put(f(*args, **keys))
        t = threading.Thread(target=queue_put_f)
        t.start()
        return t, q

    run_thread.__name__ = f.__name__ + "[background]"

    return run_thread

# ==================================================================================================

class CrdsDjangoConnection(object):

    """This class handles CRDS authentication, basic GET, basic POST, and CRDS-style get/post.
    It also manages the CSRF token generated by Django to block form forgeries and CRDS instrument
    management/locking.
    """

    def __init__(self, locked_instrument="none", username=None, password=None, base_url=None):
        self.locked_instrument = locked_instrument
        self.username = username
        self.password = password
        self.base_url = base_url
        self.session = requests.session()
        self.session.headers.update({'referer': self.base_url})

    def abs_url(self, relative_url):
        """Return the absolute server URL constructed from the given `relative_url`."""
        return self.base_url + relative_url

    def dump_response(self, name, response):
        """Print out verbose output related to web `response` from activity `name`."""
        log_section("headers:\n", response.headers, divider_name=name, verbosity=70)
        log_section("status_code:", response.status_code, verbosity=50)
        log_section("text:\n", response.text, verbosity=75)
        try:
            json_text = response.json()
            log_section("json:\n", json_text)
        except Exception:
            pass
        log.divider()

    def get(self, relative_url):
        """HTTP(S) GET `relative_url` and return the requests response object."""
        t, q = self.get_start(relative_url)
        return self.get_complete(t, q)
    
    def get_start(self, relative_url):
        url = self.abs_url(relative_url)
        log_section("GET:", url, divider_name="GET")
        t, q = self._get(url)
        return t, q

    def get_complete(self, t, q):
        t.join()
        response = q.get()
        self.dump_response("GET response:", response)
        self.check_error(response)
        return response
    
    @background
    def _get(self, url):
        return self.session.get(url)

    def post(self, relative_url, *post_dicts, **post_vars):
        """HTTP(S) POST `relative_url` and return the requests response object."""
        t, q = self.post_start(relative_url, *post_dicts, **post_vars)
        return self.post_complete(t, q)
    
    def post_start(self, relative_url, *post_dicts, **post_vars):
        url = self.abs_url(relative_url)
        vars = utils.combine_dicts(*post_dicts, **post_vars)
        log_section("POST:", vars, divider_name="POST: " + url)
        t, q = self._post(url, vars)
        return t, q

    def post_complete(self, t, q):
        t.join()
        response = q.get()
        self.dump_response("POST response: ", response)
        self.check_error(response)
        return response

    @background
    def _post(self, url, vars):
        return self.session.post(url, vars)

    def repost(self, relative_url, *post_dicts, **post_vars):
        """First GET form from ``relative_url`,  next POST form to same
        url using composition of variables from *post_dicts and **post_vars.

        Maintain Django CSRF session token.
        """
        t, q = self.repost_start(relative_url, *post_dicts, **post_vars)
        return self.repost_complete(t, q)

    def repost_start(self, relative_url, *post_dicts, **post_vars):
        """Initiate a repost,  first getting the form synchronously and extracting
        the csrf token,  then doing a post_start() of the form and returning
        the resulting thread and queue.
        """
        response = self.get(relative_url)
        csrf_token = html.fromstring(response.text).xpath(
            '//input[@name="csrfmiddlewaretoken"]/@value'
            )[0]
        post_vars['csrfmiddlewaretoken'] = csrf_token
        return self.post_start(relative_url, *post_dicts, **post_vars)

    def repost_complete(self, thread, queue):
        """Join the post `thread` and complete the post using the response
        taken from `queue`.
        """
        return self.post_complete(thread, queue)
    
    def login(self, next="/"):
        """Login to the CRDS website and proceed to relative url `next`."""
        response = self.repost(
            "/login/", 
            username = self.username,
            password = self.password, 
            instrument = self.locked_instrument,
            next = next,
            )
        self.check_login(response)
        
    def check_error(self, response):
        """Call fatal_error() if response contains an error_message <div>."""
        self._check_error(response, '//div[@id="error_message"]', "CRDS server error:")

    def check_login(self, reseponse):
        """Call fatal_error() if response contains an error_login <div>."""
        self._check_error(reseponse, '//div[@id="error_login"]', "Error logging into CRDS server:")

    def _check_error(self, response, xpath_spec, error_prefix):
        """Extract the `xpath_spec` text from `response`,  if present call fatal_error() with
        `error_prefix` and the response `xpath_spec` text.
        """
        error_msg_parse = html.fromstring(response.text).xpath(xpath_spec)
        error_message = error_msg_parse and error_msg_parse[0].text.strip()
        if error_message:
            if error_message.startswith("ERROR: "):
                error_message = error_message[len("ERROR: "):]
            log.fatal_error(error_prefix, error_message)

    def logout(self):
        """Login to the CRDS website and proceed to relative url `next`."""
        self.get("/logout/")

